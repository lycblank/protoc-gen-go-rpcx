package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage = protogen.GoImportPath("context")
	timePackage = protogen.GoImportPath("time")
	fmtPackage = protogen.GoImportPath("fmt")
	rpcxClientPackage = protogen.GoImportPath("github.com/smallnest/rpcx/client")
	protocolPackage = protogen.GoImportPath("github.com/smallnest/rpcx/protocol")
	rpcxEtcdClientPackage = protogen.GoImportPath("github.com/rpcxio/rpcx-etcd/client")
	serverPackage = protogen.GoImportPath("github.com/smallnest/rpcx/server")
	serverpluginPackage = protogen.GoImportPath("github.com/rpcxio/rpcx-etcd/serverplugin")
	metricsPackage = protogen.GoImportPath("github.com/rcrowley/go-metrics")
)

// generateFile generates a _rpcx.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_rpcx.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-rpcx. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the gRPC service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	g.P("type ", "EtcdClientConfig", " struct {")
	g.P("	BasePath ", "string")
	g.P("	ServicePath ", "string")
	g.P("	EtcdList ", "[]string")
	g.P("}")
	g.P()


	g.P(fmt.Sprintf("func NewClient(xclient %s) *Client {",
		g.QualifiedGoIdent(rpcxClientPackage.Ident("XClient"))))
	g.P("	cli := &Client {")
	g.P("		xclient: xclient,")
	g.P("	}")
	g.P("	return cli")
	g.P("}")
	g.P()

	g.P(fmt.Sprintf("func InitDefaultClient(xclient %s) {",
		g.QualifiedGoIdent(rpcxClientPackage.Ident("XClient"))))
	g.P("	defaultClient = &Client {")
	g.P("		xclient: xclient,")
	g.P("	}")
	g.P("}")
	g.P()

	g.P(fmt.Sprintf("func SetDefaultClient(cli *Client) {"))
	g.P("	defaultClient = cli")
	g.P("}")
	g.P()



	g.P(fmt.Sprintf("func NewEtcdXClient(config EtcdClientConfig) (%s, error) {",
		g.QualifiedGoIdent(rpcxClientPackage.Ident("XClient"))))
	g.P(fmt.Sprintf("	discovery, err := %s(config.BasePath, config.ServicePath, config.EtcdList, nil)",
		g.QualifiedGoIdent(rpcxEtcdClientPackage.Ident("NewEtcdDiscovery"))))
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P(fmt.Sprintf("	option := %s", g.QualifiedGoIdent(rpcxClientPackage.Ident("DefaultOption"))))
	g.P(fmt.Sprintf("	option.SerializeType = %s", g.QualifiedGoIdent(protocolPackage.Ident("ProtoBuffer"))))
	g.P(fmt.Sprintf("	xclient := %s(config.ServicePath, %s, %s, discovery, option)",
		g.QualifiedGoIdent(rpcxClientPackage.Ident("NewXClient")),
		g.QualifiedGoIdent(rpcxClientPackage.Ident("Failover")),
		g.QualifiedGoIdent(rpcxClientPackage.Ident("RandomSelect"))))
	g.P("	return xclient, nil")
	g.P("}")
	g.P()

	g.P("var defaultClient *Client")
	g.P("func Init(config EtcdClientConfig) error {")
	g.P("	xclient, err := NewEtcdXClient(config)")
	g.P("	if err != nil {")
	g.P("		return err")
	g.P("	}")
	g.P("	defaultClient = &Client{")
	g.P("		xclient: xclient,")
	g.P("	}")
	g.P("	return nil")
	g.P("}")
	g.P()

	g.P("type Client struct {")
	g.P(fmt.Sprintf("	xclient %s", g.QualifiedGoIdent(rpcxClientPackage.Ident("XClient"))))
	g.P("}")
	g.P()

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	// =============== 客户端逻辑 ================
	g.P(fmt.Sprintf("// rpcx %s client logic", service.GoName))
	for _, method := range service.Methods {
		g.Annotate("Client.Do"+method.GoName, method.Location)

		args := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		if !method.Desc.IsStreamingClient() {
			args += ", args *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}

		reply := g.QualifiedGoIdent(method.Output.GoIdent)

		g.P(fmt.Sprintf("func (c *Client) Do%s(%s) (*%s, error) {", method.GoName, args, reply))
		g.P(fmt.Sprintf("	reply := &%s{}", reply))
		g.P(fmt.Sprintf("	err := c.xclient.Call(ctx, \"%s\", args, reply)", method.GoName))
		g.P(fmt.Sprintf("	return reply, err"))
		g.P(fmt.Sprintf("}"))
		g.P()

		g.P(fmt.Sprintf("func (c *Client) Go%s(%s) error {", method.GoName, args))
		g.P(fmt.Sprintf("	reply := &%s{}", reply))
		g.P(fmt.Sprintf("	_, err := c.xclient.Go(ctx, \"%s\", args, reply, nil)", method.GoName))
		g.P(fmt.Sprintf("	return err"))
		g.P(fmt.Sprintf("}"))
		g.P()
	}
	for _, method := range service.Methods {
		g.Annotate("Client.Do"+method.GoName, method.Location)
		args := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		if !method.Desc.IsStreamingClient() {
			args += ", args *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}

		reply := g.QualifiedGoIdent(method.Output.GoIdent)

		g.P(fmt.Sprintf("func Do%s(%s) (*%s, error) {", method.GoName, args, reply))
		g.P(fmt.Sprintf("	return defaultClient.Do%s(ctx, args)", method.GoName))
		g.P(fmt.Sprintf("}"))
		g.P()

		g.P(fmt.Sprintf("func Go%s(%s) error {", method.GoName, args))
		g.P(fmt.Sprintf("	return defaultClient.Go%s(ctx, args)", method.GoName))
		g.P(fmt.Sprintf("}"))
		g.P()
	}

	g.P(fmt.Sprintf("// rpcx %s server logic", service.GoName))
	g.P(fmt.Sprintf("type %sAble interface {", service.GoName))
	for _, method := range service.Methods {
		args := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		args += ", args *" + g.QualifiedGoIdent(method.Input.GoIdent)
		args += ", reply *" + g.QualifiedGoIdent(method.Output.GoIdent)
		g.P(fmt.Sprintf("	%s(%s) error", method.GoName, args))
	}
	g.P(fmt.Sprintf("}"))
	g.P()

	g.P("type ServerConfig struct {")
	g.P("	PublishHost string           `json:\"publish_host\"`")
	g.P("	PublishPort string           `json:\"publish_port\"`")
	g.P("	EtcdList []string            `json:\"etcd_list\"`")
	g.P("	BasePath string              `json:\"base_path\"`")
	g.P(fmt.Sprintf("	UpdateInterval %s `json:\"update_interval\"`", g.QualifiedGoIdent(timePackage.Ident("Duration"))))
	g.P("	ServicePath string           `json:\"service_path\"`")
	g.P("	Host string                  `json:\"host\"`")
	g.P("	Port string                  `json:\"port\"`")
	g.P("}")

	g.P(fmt.Sprintf("func CreateEtcdDiscoveryServer(config ServerConfig, rpcService interface{}, plugins ...%s) error {",
		g.QualifiedGoIdent(serverPackage.Ident("Plugin"))))
	g.P(fmt.Sprintf("	s := %s()", g.QualifiedGoIdent(serverPackage.Ident("NewServer"))))
	g.P(fmt.Sprintf("	plugin := &%s {", g.QualifiedGoIdent(serverpluginPackage.Ident("EtcdRegisterPlugin"))))
	g.P(fmt.Sprintf("		ServiceAddress: %s(\"tcp@%%s:%%s\", config.PublishHost, config.PublishPort),",
		g.QualifiedGoIdent(fmtPackage.Ident("Sprintf"))))
	g.P("		EtcdServers:config.EtcdList,")
	g.P("		BasePath: config.BasePath,")
	g.P(fmt.Sprintf("		Metrics:  %s(),", g.QualifiedGoIdent(metricsPackage.Ident("NewRegistry"))))
	g.P("		UpdateInterval: config.UpdateInterval,")
	g.P("	}")
	g.P("	if err := plugin.Start(); err != nil {")
	g.P("		return err")
	g.P("	}")
	g.P("	s.Plugins.Add(plugin)")
	g.P("	for _, plugin := range plugins {")
	g.P("		s.Plugins.Add(plugin)")
	g.P("	}")
	g.P()
	g.P("	if err := s.RegisterName(config.ServicePath, rpcService, \"\"); err != nil {")
	g.P("		return err")
	g.P("	}")
	g.P()
	g.P(fmt.Sprintf("	if err := s.Serve(\"tcp\", %s(\"%%s:%%s\", config.Host, config.Port)); err != nil {",
		g.QualifiedGoIdent(fmtPackage.Ident("Sprintf"))))
	g.P("		return err")
	g.P("	}")
	g.P("	return nil")
	g.P("}")
}